---
title: "Using Query Namespaces"
author: "James P. Gilbert"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
  html_document:
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteIndexEntry{UsingQueryNamespaces"}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

# Purpose
The `QueryNamespace` class is designed to be a convenient way to write (and re-write) SQL queries for packages with
defined result model specifications.
The convenience is that only passed parameters must be set in the query - any table names or other pre-defined variables
can be set once in a result spec and reused if table prefixes are applied to the tables.
The intention is to save time and limit bugs.
This also builds on the `SqlRender`/`DatabaseConnector` principle of "Write sql once, use anywhere" principle across
ohdsi packages.
This is not intended to replace usage of `dbplyr` style operations which are expressive and allow use of sql.
However, many find that writing SQL strings is often more convenient and portable to other programming language
than `dplyr` calls allow.

# Basic usage
The most basic usage is to create a specification with a single table that conforms to a valid data model specification
```{r}
library(ResultModelManager)

tableSpecification <- data.frame(
  tableName = "cohort_definition",
  columnName = c("cohort_definition_id", "cohort_name", "json", "sql"),
  primaryKey = c("yes", "no", "no", "no"),
  dataType = c("bigint", "varchar", "varchar", "varchar")
)
```
Note, that generally we would save these tables to a csv file that can be loaded.

We then load a `QueryNamespace` instance with this table:

```{r}
connectionDetails <- DatabaseConnector::createConnectionDetails("sqlite", server = tempfile())
qns <- createQueryNamespace(
  connectionDetails = connectionDetails,
  usePooledConnection = FALSE,
  tableSpecification = tableSpecification,
  tablePrefix = "rwe_study_99_",
  snakeCaseToCamelCase = TRUE,
  database_schema = "main"
)

# Create our schema within the namespace
sql <- generateSqlSchema(schemaDefinition = tableSpecification)
# note - the table prefix and schema parameters are not neeeded
qns$executeSql(sql)
```
We can then query the table with sql that automatically replaces the table names:

```{r}
qns$queryDb("SELECT * FROM @database_schema.@cohort_definition")
```
Note that the underlying query is already handling our `tablePrefix` for us, so we don't need to add it:

```{r}
qns$queryDb("SELECT * FROM @database_schema.@cohort_definition")
```

# Adding replacement variables at runtime
Variables can naturally be added at runtime, for example, in a query:
```{r}
qns$queryDb("SELECT * FROM @database_schema.@cohort_definition WHERE cohort_definition_id = @id",
  id = 5
)
```
Alternatively we can persist the id in the object for use in all queries.

```{r}
qns$addReplacementVariable("database_id", "my_cdm")
```
Note that replacing the same variable will result in an error
```{r, eval = FALSE}
qns$addReplacementVariable("database_id", "my_cdm")
```


We can also add to the table specification

```{r}
tableSpecification2 <- data.frame(
  tableName = "database_info",
  columnName = c("database_id", "database_name"),
  primaryKey = c("yes", "no"),
  dataType = c("varchar", "varchar")
)
qns$addTableSpecification(tableSpecification2)
```
# Using type checks and sql files

Optionally, you may wish to write sql only files and not require any R boilerplate.
Query namespaces support this in two ways.
Firstly, they allow you to add a file that is loaded as a method in the querynamespace class at runtime.
Secondly, you can enforce type checking within these SQL files using the notation `{TYPEC <TYPE>}` or `{TYPEC <TYPE>[]}`
to allow vectors of length +1.

## TYPEC annotation
To add runtime checks to any sql statement within a query namespace add one of the following checks:

```{sql}
{TYPEC INT @variable_name}
{TYPEC INT[] @variable_name}
{TYPEC BIGINT @variable_name}
{TYPEC BIGINT[] @variable_name}
{TYPEC CHAR @variable_name}
{TYPEC CHAR[] @variable_name}
{TYPEC NUMERIC @variable_name}
{TYPEC NUMERIC[] @variable_name}
{TYPEC INT @variable_name}
{TYPEC INT[] @variable_name}
```
In this situation, a value passed to an SQL query can never be `NULL` or `NA` and must be of the type specified.

For example:

```{r}
qns$queryDb(
  "{TYPEC INT @id} SELECT * FROM @database_schema.@cohort_definition WHERE cohort_definition_id = @id",
  id = 5
)
```
In this case, if a non-integer value is passed into the SQL an error will be thrown prior to execution within the database.


## Adding sql files

For longer sql queries, using `.sql` files can be a more convenient way of managing these.
To do this create a file that maps to the function name you wish to attach to the query namespace and add it as follows:

```{sql}
-- CREATE the sql file

-- set the required types for input
{TYPEC INT @ids[]}
{TYPEC CHAR @database_schema}
{TYPEC CHAR @cohort_definition}

SELECT * FROM @database_schema.@cohort_definition
WHERE cohort_definition_id IN (@ids)
```

```{r eval=FALSE}
# requires getResults.sql to exist
qns$addQueryFile("getResults.sql")
results <- qns$getResults(id = 12)
results2 <- qns$getResults(id = c(5, 6, 7, 8))
```
Optionally, we can attach this when creating the object

```{r eval=FALSE}
qns2 <- createQueryNamespace(
  connectionDetails = connectionDetails,
  usePooledConnection = FALSE,
  tableSpecification = tableSpecification,
  tablePrefix = "rwe_study_99_",
  snakeCaseToCamelCase = TRUE,
  database_schema = "main",
  queryFiles = c("getResults.sql")
)
```
If you're creating a model within a package you may wish to expose a results model as follows:

```{r eval = FALSE}
#' @expose
myResultsMode <- function() {
  createQueryNamespace(
    connectionDetails = connectionDetails,
    usePooledConnection = FALSE,
    tableSpecification = tableSpecification,
    tablePrefix = "rwe_study_99_",
    snakeCaseToCamelCase = TRUE,
    database_schema = "main",
    queryFiles = list.files(system.file("sql", "resultsModel",
                                        package = utils::packageName()),
                            "*.sql",
                            full.names = TRUE)
  )
}

```

This would expose all of the `.sql` files in the `inst/sql/resultsModel` folder of your package as methods within the query namespace.